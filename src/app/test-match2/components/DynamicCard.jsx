'use client';
import React from 'react';
import { 
  useRive, 
  useViewModel,
  useViewModelInstance,
  useViewModelInstanceNumber,
  useViewModelInstanceBoolean,
  useViewModelInstanceImage,
  Layout,
  Fit,
  Alignment,
  decodeImage
} from '@rive-app/react-webgl2';

// Dynamic Card Component
const DynamicCard = React.memo(({ 
  cardIndex, 
  onValueChange, 
  onOpenChange, 
  mode = 'display', 
  cardState = {}, 
  isGameStarted = false, 
  cardStates = {}, 
  pointerEventsEnabled = true,
  twoCardOpenNoMatch = false, // Th√™m prop m·ªõi
  twoCardOpenAndMatch = false, // Th√™m prop m·ªõi
  startRestartAnimation = false, // Th√™m prop m·ªõi cho START/RESTART animation
  label = null, // Th√™m prop m·ªõi cho image URL
  labelOn = false, // Th√™m prop m·ªõi cho boolean
  valueImg = null, // Th√™m prop m·ªõi cho image URL
  valueImgOn = false, // Th√™m prop m·ªõi cho boolean
  style = {}
}) => {
  const { rive, RiveComponent } = useRive({
    src: '/assets/animation/match_2_card.riv',
    stateMachines: ['State Machine 1'],
    autoplay: true,
    // fit: 'contain',
    layout: new Layout({
      fit: Fit.Contain,
      alignment: Alignment.Center,
    }),
    onLoad: () => console.log(`Match 2 Card Rive ${cardIndex} loaded`),
  });

  const cardViewModel = useViewModel(rive, { name: 'card' });
  const cardInstance = useViewModelInstance(cardViewModel, { useNew: true, rive });
  
  const { value: cardValue, setValue: setCardValue } = useViewModelInstanceNumber('cardValue', cardInstance);
  const { value: cardOpen, setValue: setCardOpen } = useViewModelInstanceBoolean('cardOpen', cardInstance);
  const { value: matched, setValue: setMatched } = useViewModelInstanceBoolean('matched', cardInstance);
  const { value: gameStarted, setValue: setGameStarted } = useViewModelInstanceBoolean('gameStarted', cardInstance);
  
  // Th√™m c√°c tr·∫°ng th√°i m·ªõi cho Rive
  const { setValue: setTwoCardOpenNoMatch } = useViewModelInstanceBoolean('twoCardOpenNoMatch', cardInstance);
  const { setValue: setTwoCardOpenAndMatch } = useViewModelInstanceBoolean('twoCardOpenAndMatch', cardInstance);
  const { setValue: setStartRestartAnimation } = useViewModelInstanceBoolean('startRestartAnimation', cardInstance);
  const { setValue: setLabel } = useViewModelInstanceImage('label', cardInstance);
  const { setValue: setLabelOn } = useViewModelInstanceBoolean('labelOn', cardInstance);
  const { setValue: setValueImg } = useViewModelInstanceImage('valueImg', cardInstance);
  const { setValue: setValueImgOn } = useViewModelInstanceBoolean('valueImgOn', cardInstance);
  
  // Ch·ªâ ƒë·ªìng b·ªô m·ªôt chi·ªÅu: external state -> Rive (single source of truth)
  React.useEffect(() => {
    if (cardState.value !== undefined && setCardValue) {
      setCardValue(cardState.value);
    }
  }, [cardState.value, setCardValue]);
  
  React.useEffect(() => {
    if (cardState.open !== undefined && setCardOpen) {
      setCardOpen(cardState.open);
    }
  }, [cardState.open, setCardOpen]);
  
  React.useEffect(() => {
    if (cardState.matched !== undefined && setMatched) {
      setMatched(cardState.matched);
    }
  }, [cardState.matched, setMatched]);
  
  React.useEffect(() => {
    if (isGameStarted !== undefined && setGameStarted) {
      setGameStarted(isGameStarted);
    }
  }, [isGameStarted, setGameStarted]);
  
  // ƒê·ªìng b·ªô twoCardOpenNoMatch t·ª´ React state v√†o Rive
  React.useEffect(() => {
    if (twoCardOpenNoMatch !== undefined && setTwoCardOpenNoMatch) {
      setTwoCardOpenNoMatch(twoCardOpenNoMatch);
    }
  }, [twoCardOpenNoMatch, setTwoCardOpenNoMatch]);
  
  // ƒê·ªìng b·ªô twoCardOpenAndMatch t·ª´ React state v√†o Rive
  React.useEffect(() => {
    if (twoCardOpenAndMatch !== undefined && setTwoCardOpenAndMatch) {
      setTwoCardOpenAndMatch(twoCardOpenAndMatch);
    }
  }, [twoCardOpenAndMatch, setTwoCardOpenAndMatch]);
  
  // ƒê·ªìng b·ªô startRestartAnimation t·ª´ React state v√†o Rive
  React.useEffect(() => {
    if (startRestartAnimation !== undefined && setStartRestartAnimation) {
      setStartRestartAnimation(startRestartAnimation);
    }
  }, [startRestartAnimation, setStartRestartAnimation]);
  
  // ƒê·ªìng b·ªô label t·ª´ React state v√†o Rive - ch·ªâ khi labelOn = true
  React.useEffect(() => {
    const loadAndSetLabel = async () => {
      if (label !== null && setLabel && labelOn) {
        try {
          console.log(`üéØ DynamicCard[${cardIndex}] loading label: ${label} (labelOn: ${labelOn})`);
          
          // Fetch image and convert to arrayBuffer
          const response = await fetch(label);
          if (!response.ok) {
            throw new Error(`Failed to fetch label image: ${response.status}`);
          }
          
          const imageBuffer = await response.arrayBuffer();
          
          // Decode the image from the response
          const decodedImage = await decodeImage(new Uint8Array(imageBuffer));
          setLabel(decodedImage);
          
          // Clean up the decoded image
          decodedImage.unref();
          
          console.log(`‚úÖ DynamicCard[${cardIndex}] successfully set label`);
        } catch (error) {
          console.error(`‚ùå DynamicCard[${cardIndex}] Failed to load label:`, error);
          // Set null on error
          setLabel(null);
        }
      } else if (setLabel && !labelOn) {
        console.log(`üéØ DynamicCard[${cardIndex}] clearing label because labelOn is false`);
        setLabel(null);
      }
    };
    
    loadAndSetLabel();
  }, [label, setLabel, cardIndex, labelOn]);
  
  // ƒê·ªìng b·ªô labelOn t·ª´ React state v√†o Rive
  React.useEffect(() => {
    if (labelOn !== undefined && setLabelOn) {
      setLabelOn(labelOn);
    }
  }, [labelOn, setLabelOn]);
  
  // ƒê·ªìng b·ªô valueImg t·ª´ React state v√†o Rive - ch·ªâ khi valueImgOn = true
  React.useEffect(() => {
    console.log(`üîç DynamicCard[${cardIndex}] valueImg effect: valueImg=${valueImg}, valueImgOn=${valueImgOn}`);
    
    const loadAndSetImage = async () => {
      if (valueImg !== null && setValueImg && valueImgOn) {
        try {
          console.log(`üéØ DynamicCard[${cardIndex}] loading valueImg: ${valueImg} (valueImgOn: ${valueImgOn})`);
          
          // Fetch image and convert to arrayBuffer
          const response = await fetch(valueImg);
          if (!response.ok) {
            throw new Error(`Failed to fetch image: ${response.status}`);
          }
          
          const imageBuffer = await response.arrayBuffer();
          
          // Decode the image from the response
          const decodedImage = await decodeImage(new Uint8Array(imageBuffer));
          setValueImg(decodedImage);
          
          // Clean up the decoded image
          decodedImage.unref();
          
          console.log(`‚úÖ DynamicCard[${cardIndex}] successfully set valueImg`);
        } catch (error) {
          console.error(`‚ùå DynamicCard[${cardIndex}] Failed to load valueImg:`, error);
          // Set null on error
          setValueImg(null);
        }
      } else if (setValueImg && !valueImgOn) {
        console.log(`üéØ DynamicCard[${cardIndex}] clearing valueImg because valueImgOn is false`);
        setValueImg(null);
      }
    };
    
    loadAndSetImage();
  }, [valueImg, setValueImg, cardIndex, valueImgOn]);
  
  // ƒê·ªìng b·ªô valueImgOn t·ª´ React state v√†o Rive
  React.useEffect(() => {
    if (valueImgOn !== undefined && setValueImgOn) {
      setValueImgOn(valueImgOn);
    }
  }, [valueImgOn, setValueImgOn]);
  
  // Ch·ªâ kh·ªüi t·∫°o state ban ƒë·∫ßu t·ª´ Rive m·ªôt l·∫ßn duy nh·∫•t
  const [initialized, setInitialized] = React.useState(false);
  React.useEffect(() => {
    if (!initialized && cardValue !== undefined && cardOpen !== undefined && 
        cardState.value === undefined && cardState.open === undefined) {
      if (onValueChange && onOpenChange) {
        onValueChange(cardIndex, cardValue || 0);
        onOpenChange(cardIndex, cardOpen || false);
        setInitialized(true)
      }
    }
  }, [cardValue, cardOpen, cardState.value, cardState.open, cardIndex, onValueChange, onOpenChange, initialized]);

  // Handle value changes - ch·ªâ c·∫≠p nh·∫≠t external state (single source of truth)
  const handleValueChange = React.useCallback((newValue) => {
    if (onValueChange) {
      onValueChange(cardIndex, newValue);
    }
  }, [cardIndex, onValueChange]);

  const handleOpenChange = React.useCallback((newOpen) => {
    if (onOpenChange) {
      onOpenChange(cardIndex, newOpen);
    }
  }, [cardIndex, onOpenChange]);
  
  // T·∫Øt ho√†n to√†n t∆∞∆°ng t√°c tr·ª±c ti·∫øp v·ªõi Rive - ch·ªâ ƒëi·ªÅu khi·ªÉn qua React state
  React.useEffect(() => {
    if (mode === 'display' && rive && rive.canvas) {
      // T·∫Øt pointer events ƒë·ªÉ ngƒÉn user click tr·ª±c ti·∫øp v√†o Rive
      rive.canvas.style.pointerEvents = 'none';
      
      return () => {
        // Cleanup: kh√¥i ph·ª•c pointer events n·∫øu c·∫ßn
        if (rive.canvas) {
          rive.canvas.style.pointerEvents = 'auto';
        }
      };
    }
  }, [mode, rive]);

  if (mode === 'control') {
    return (
      <div className={`flex items-center gap-1 rounded text-xs`}>
        <span className="font-medium w-8">C{cardIndex + 1}:</span>
        <input
          type="number"
          value={cardState.value ?? 1}
          onChange={(e) => handleValueChange(Number(e.target.value))}
          className="w-8 p-0.5 border border-gray-300 rounded text-xs"
        />
        <input
          type="checkbox"
          checked={cardState.open ?? false}
          onChange={(e) => handleOpenChange(e.target.checked)}
          className="w-6 h-6"
        />
      </div>
    );
  }

  return (
    <div 
      className={`flex items-center justify-center relative overflow-hidden rounded-lg ${
        pointerEventsEnabled ? 'cursor-pointer' : 'pointer-events-none'
      }`}
      style={{ 
        width: '100%',
        height: '100%',
        ...style
      }}
      onClick={() => {
        // NgƒÉn click khi pointer events b·ªã t·∫Øt
        if (!pointerEventsEnabled) return;
        
        // NgƒÉn click khi game ch∆∞a b·∫Øt ƒë·∫ßu
        if (!isGameStarted) return;
        
        // NgƒÉn click v√†o th·∫ª ƒë√£ matched
        if (cardState.matched) return;
        
        // Ch·ªâ cho ph√©p thay ƒë·ªïi open state qua React logic
        const currentOpen = cardState.open;
        handleOpenChange(!currentOpen);
      }}
    >
      {RiveComponent && (
        <RiveComponent 
          style={{ 
            width: '100%', 
            height: '100%', 
            display: 'block',
            objectFit: 'contain'
          }} 
        />
      )}
      {/* Overlay ƒë·ªÉ b·∫Øt click events */}
      <div 
        className="absolute inset-0 z-10"
        style={{ pointerEvents: pointerEventsEnabled ? 'auto' : 'none' }}
      />
    </div>
  );
});

DynamicCard.displayName = 'DynamicCard';

export default DynamicCard;